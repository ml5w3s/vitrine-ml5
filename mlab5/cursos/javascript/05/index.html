<!--curso_javascript/05/index.html-->
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <link rel="icon" type="image/x-icon" href="/vitrine-ml5/mlab5/images/ml5w3s.ico">
  <title>Aula 05 - Assincronismo e Comunicação | ML5Lab</title>

  <!-- SEO  -->
  <meta name="description" content="Aprenda assincronismo em JavaScript: Event Loop, Promises, async/await, Fetch API e tratamento de erros para aplicações modernas.">
  <meta name="keywords" content="javascript, assincronismo, promises, async await, fetch api, event loop, tratamento erros">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://ml5w3s.com.br/">
  <meta http-equiv="content-language" content="pt-BR">

  <!-- OG -->
  <meta property="og:title" content="Aula 05 - Assincronismo e Comunicação | ML5Lab">
  <meta property="og:description" content="Aprenda assincronismo em JavaScript: Event Loop, Promises, async/await, Fetch API e tratamento de erros para aplicações modernas.">
  <meta property="og:image" content="http://ml5w3s.com.br/images/banner_barramento.png">
  <meta property="og:url" content="http://ml5w3s.com.br">
  <meta property="og:type" content="website">

  <!-- CSS  -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href="/vitrine-ml5/mlab5/css/base.css" type="text/css" rel="stylesheet" media="screen,projection"/>
  <style>#exercicios, #controles{display:none;}</style>
  
  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Aula 05 - Assincronismo e Comunicação | ML5Lab">
  <meta name="twitter:description" content="Aprenda assincronismo em JavaScript: Event Loop, Promises, async/await, Fetch API e tratamento de erros para aplicações modernas.">
  <meta name="twitter:image" content="http://ml5w3s.com.br/images/banner_barramento.png">
</head>

<body>

<!-- COMPONENTES -->
<div id="header-placeholder"></div>
<main id="aulas">

<!-- ARTIGOS -->
<section class="container">
<article class="item">
  <picture>
    <source media="(min-width: 1024px)" srcset="/vitrine-ml5/mlab5/images/banner_frontend_desktop.png">
    <source media="(min-width: 600px)" srcset="/vitrine-ml5/mlab5/images/banner_frontend_tablet.png">
    <img src="/vitrine-ml5/mlab5/images/banner_frontend_mobile.png">
  </picture>
  <h3>⚡ Assincronismo e Comunicação</h3>
</article>
</section>

<section class="container">
<!--INSTRUÇÕES-->
<article class="item">
  <h3>Introdução ao Event Loop</h3>
  <p>O Event Loop é o mecanismo que permite JavaScript executar código de forma assíncrona em um ambiente single-threaded. Entender como funciona é fundamental para escrever código assíncrono eficiente.</p>
  <h4>Componentes do Event Loop:</h4>
  <ul class="left_list">
    <li><strong>Call Stack:</strong> Pilha de execução principal</li>
    <li><strong>Web APIs:</strong> setTimeout, DOM, AJAX</li>
    <li><strong>Callback Queue:</strong> Fila de callbacks prontos</li>
    <li><strong>Microtask Queue:</strong> Promises e queueMicrotask</li>
    <li><strong>Event Loop:</strong> Coordena a execução</li>
  </ul>
</article>

<article class="item">
  <picture>
    <source media="(min-width: 1024px)" srcset="/vitrine-ml5/mlab5/cursos/javascript/05/images/event_loop_desktop.png">
    <source media="(min-width: 600px)" srcset="/vitrine-ml5/mlab5/cursos/javascript/05/images/event_loop_tablet.png">
    <img src="/vitrine-ml5/mlab5/cursos/javascript/05/images/event_loop_mobile.png">
  </picture>
</article>
</section>

<section class="container">
<article class="item">
  <h3>Promises - Fundamentos</h3>
  <p>Promises representam o resultado eventual de uma operação assíncrona, oferecendo uma alternativa mais limpa aos callbacks aninhados e facilitando o tratamento de erros.</p>
  <h4>Estados de uma Promise:</h4>
  <ul class="left_list">
    <li><strong>Pending:</strong> Estado inicial, nem fulfilled nem rejected</li>
    <li><strong>Fulfilled:</strong> Operação completada com sucesso</li>
    <li><strong>Rejected:</strong> Operação falhou</li>
    <li><strong>Settled:</strong> Promise foi resolved ou rejected</li>
  </ul>
</article>

<article class="item">
  <h4>Exemplos de Promises:</h4>
  <pre><code>// ✅ Criando uma Promise
const minhaPromise = new Promise((resolve, reject) => {
  const sucesso = Math.random() > 0.5;
  
  setTimeout(() => {
    if (sucesso) {
      resolve('Operação bem-sucedida!');
    } else {
      reject(new Error('Algo deu errado!'));
    }
  }, 1000);
});

// ✅ Consumindo Promise com .then()
minhaPromise
  .then(resultado => {
    console.log('Sucesso:', resultado);
    return 'Processando resultado...';
  })
  .then(resultadoProcessado => {
    console.log('Resultado processado:', resultadoProcessado);
  })
  .catch(erro => {
    console.error('Erro capturado:', erro.message);
  })
  .finally(() => {
    console.log('Promise finalizada (sucesso ou erro)');
  });

// ✅ Promise com fetch
const buscarUsuario = (id) => {
  return fetch(`https://jsonplaceholder.typicode.com/users/${id}`)
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    });
};

// ✅ Usando Promise
buscarUsuario(1)
  .then(usuario => {
    console.log('Usuário encontrado:', usuario.name);
    return buscarUsuario(2);
  })
  .then(outroUsuario => {
    console.log('Segundo usuário:', outroUsuario.name);
  })
  .catch(erro => {
    console.error('Erro ao buscar usuários:', erro);
  });

// ✅ Promise.all - Executar múltiplas promises em paralelo
const promises = [
  buscarUsuario(1),
  buscarUsuario(2),
  buscarUsuario(3)
];

Promise.all(promises)
  .then(usuarios => {
    console.log('Todos os usuários:', usuarios);
  })
  .catch(erro => {
    console.error('Erro em uma das requisições:', erro);
  });

// ✅ Promise.allSettled - Aguardar todas, independente do resultado
Promise.allSettled(promises)
  .then(resultados => {
    resultados.forEach((resultado, index) => {
      if (resultado.status === 'fulfilled') {
        console.log(`Usuário ${index + 1}:`, resultado.value.name);
      } else {
        console.log(`Erro no usuário ${index + 1}:`, resultado.reason);
      }
    });
  });

// ✅ Promise.race - Primeira promise a resolver
const timeoutPromise = new Promise((_, reject) => 
  setTimeout(() => reject(new Error('Timeout')), 5000)
);

Promise.race([buscarUsuario(1), timeoutPromise])
  .then(usuario => {
    console.log('Usuário carregado antes do timeout:', usuario.name);
  })
  .catch(erro => {
    console.error('Timeout ou erro:', erro.message);
  });</code></pre>
</article>
</section>

<section class="container">
<article class="item">
  <h3>Async/Await - Sintaxe Moderna</h3>
  <p>Async/await é uma sintaxe mais limpa para trabalhar com Promises, tornando o código assíncrono mais legível e similar ao código síncrono tradicional.</p>
  <h4>Vantagens do Async/Await:</h4>
  <ul class="left_list">
    <li>Código mais legível e limpo</li>
    <li>Tratamento de erros simplificado</li>
    <li>Debugging mais fácil</li>
    <li>Composição de operações assíncronas</li>
    <li>Sintaxe familiar para desenvolvedores</li>
  </ul>
</article>

<article class="item">
  <h4>Exemplos de Async/Await:</h4>
  <pre><code>// ✅ Função async básica
async function buscarDados() {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
    const dados = await response.json();
    console.log('Dados carregados:', dados);
    return dados;
  } catch (erro) {
    console.error('Erro ao carregar dados:', erro);
    throw erro;
  }
}

// ✅ Múltiplas operações sequenciais
async function processarUsuario(id) {
  try {
    console.log('Buscando usuário...');
    const usuario = await buscarUsuario(id);
    
    console.log('Buscando posts do usuário...');
    const posts = await buscarPostsUsuario(id);
    
    console.log('Buscando comentários...');
    const comentarios = await buscarComentarios(id);
    
    return {
      usuario,
      posts,
      comentarios
    };
  } catch (erro) {
    console.error('Erro no processamento:', erro);
    throw erro;
  }
}

// ✅ Operações em paralelo com Promise.all
async function carregarDadosCompletos(ids) {
  try {
    const promises = ids.map(id => buscarUsuario(id));
    const usuarios = await Promise.all(promises);
    
    console.log('Todos os usuários carregados:', usuarios);
    return usuarios;
  } catch (erro) {
    console.error('Erro ao carregar usuários:', erro);
  }
}

// ✅ Tratamento de erros robusto
async function operacaoComRetry(maxTentativas = 3) {
  for (let tentativa = 1; tentativa <= maxTentativas; tentativa++) {
    try {
      console.log(`Tentativa ${tentativa}...`);
      const resultado = await operacaoAssincrona();
      console.log('Sucesso na tentativa', tentativa);
      return resultado;
    } catch (erro) {
      console.error(`Tentativa ${tentativa} falhou:`, erro.message);
      
      if (tentativa === maxTentativas) {
        throw new Error(`Operação falhou após ${maxTentativas} tentativas`);
      }
      
      // Aguardar antes da próxima tentativa
      await aguardar(1000 * tentativa);
    }
  }
}

// ✅ Função auxiliar para aguardar
const aguardar = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// ✅ Async/await com Promise.allSettled
async function carregarDadosResiliente(urls) {
  const promises = urls.map(url => fetch(url).then(r => r.json()));
  const resultados = await Promise.allSettled(promises);
  
  const sucessos = resultados
    .filter(r => r.status === 'fulfilled')
    .map(r => r.value);
    
  const erros = resultados
    .filter(r => r.status === 'rejected')
    .map(r => r.reason);
  
  console.log('Dados carregados com sucesso:', sucessos.length);
  console.log('Erros encontrados:', erros.length);
  
  return { sucessos, erros };
}

// ✅ Async/await em loops
async function processarLista(items) {
  const resultados = [];
  
  // Processamento sequencial (um por vez)
  for (const item of items) {
    const resultado = await processarItem(item);
    resultados.push(resultado);
  }
  
  // OU processamento paralelo (todos ao mesmo tempo)
  const promises = items.map(item => processarItem(item));
  const resultadosParalelos = await Promise.all(promises);
  
  return resultadosParalelos;
}

// ✅ Função async como IIFE
(async () => {
  try {
    const dados = await buscarDados();
    console.log('Dados carregados:', dados);
  } catch (erro) {
    console.error('Erro:', erro);
  }
})();</code></pre>
</article>
</section>

<section class="container">
<article class="item">
  <h3>Fetch API - Requisições HTTP Modernas</h3>
  <p>A Fetch API é a forma moderna de fazer requisições HTTP em JavaScript, oferecendo uma interface mais limpa e flexível que o antigo XMLHttpRequest.</p>
  <h4>Características da Fetch API:</h4>
  <ul class="left_list">
    <li>Baseada em Promises</li>
    <li>Interface mais limpa</li>
    <li>Suporte a streaming</li>
    <li>Integração com Service Workers</li>
    <li>Configurações flexíveis</li>
  </ul>
</article>

<article class="item">
  <h4>Exemplos de Fetch API:</h4>
  <pre><code>// ✅ Fetch básico
async function buscarDados() {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const dados = await response.json();
    return dados;
  } catch (erro) {
    console.error('Erro na requisição:', erro);
    throw erro;
  }
}

// ✅ Fetch com configurações
async function criarPost(dados) {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/posts', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer token123'
      },
      body: JSON.stringify(dados)
    });
    
    if (!response.ok) {
      throw new Error(`Erro HTTP: ${response.status}`);
    }
    
    const novoPost = await response.json();
    return novoPost;
  } catch (erro) {
    console.error('Erro ao criar post:', erro);
    throw erro;
  }
}

// ✅ Upload de arquivo
async function uploadArquivo(arquivo) {
  const formData = new FormData();
  formData.append('arquivo', arquivo);
  
  try {
    const response = await fetch('/api/upload', {
      method: 'POST',
      body: formData
    });
    
    const resultado = await response.json();
    return resultado;
  } catch (erro) {
    console.error('Erro no upload:', erro);
    throw erro;
  }
}

// ✅ Fetch com timeout
async function fetchComTimeout(url, timeoutMs = 5000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
  
  try {
    const response = await fetch(url, {
      signal: controller.signal
    });
    
    clearTimeout(timeoutId);
    return response;
  } catch (erro) {
    clearTimeout(timeoutId);
    
    if (erro.name === 'AbortError') {
      throw new Error('Requisição cancelada por timeout');
    }
    
    throw erro;
  }
}

// ✅ Cancelar requisição
let controller = new AbortController();

async function buscarDadosCancelaveis() {
  try {
    const response = await fetch('/api/dados', {
      signal: controller.signal
    });
    
    const dados = await response.json();
    return dados;
  } catch (erro) {
    if (erro.name === 'AbortError') {
      console.log('Requisição cancelada');
    } else {
      console.error('Erro na requisição:', erro);
    }
    throw erro;
  }
}

// Função para cancelar
function cancelarRequisicao() {
  controller.abort();
}

// ✅ Fetch com retry automático
async function fetchComRetry(url, maxTentativas = 3) {
  for (let tentativa = 1; tentativa <= maxTentativas; tentativa++) {
    try {
      const response = await fetch(url);
      
      if (!response.ok && response.status >= 500) {
        throw new Error(`Erro do servidor: ${response.status}`);
      }
      
      return response;
    } catch (erro) {
      console.error(`Tentativa ${tentativa} falhou:`, erro.message);
      
      if (tentativa === maxTentativas) {
        throw erro;
      }
      
      // Aguardar antes da próxima tentativa (exponential backoff)
      await aguardar(Math.pow(2, tentativa) * 1000);
    }
  }
}

// ✅ Fetch com cache
const cache = new Map();

async function fetchComCache(url) {
  if (cache.has(url)) {
    console.log('Retornando do cache:', url);
    return cache.get(url);
  }
  
  try {
    const response = await fetch(url);
    const dados = await response.json();
    
    cache.set(url, dados);
    console.log('Dados armazenados no cache:', url);
    
    return dados;
  } catch (erro) {
    console.error('Erro ao buscar dados:', erro);
    throw erro;
  }
}

// ✅ Fetch com progress
async function downloadComProgresso(url, onProgress) {
  const response = await fetch(url);
  const reader = response.body.getReader();
  const contentLength = +response.headers.get('Content-Length');
  
  let receivedLength = 0;
  const chunks = [];
  
  while (true) {
    const { done, value } = await reader.read();
    
    if (done) break;
    
    chunks.push(value);
    receivedLength += value.length;
    
    if (onProgress) {
      onProgress(receivedLength, contentLength);
    }
  }
  
  const chunksAll = new Uint8Array(receivedLength);
  let position = 0;
  
  for (const chunk of chunks) {
    chunksAll.set(chunk, position);
    position += chunk.length;
  }
  
  return new Blob([chunksAll]);
}</code></pre>

  <picture>
    <source media="(min-width: 1024px)" srcset="/vitrine-ml5/mlab5/cursos/javascript/05/images/fetch_api_desktop.png">
    <source media="(min-width: 600px)" srcset="/vitrine-ml5/mlab5/cursos/javascript/05/images/fetch_api_tablet.png">
    <img src="/vitrine-ml5/mlab5/cursos/javascript/05/images/fetch_api_mobile.png">
  </picture>
</article>
</section>

<section class="container">
<article class="item">
  <h3>Tratamento de Erros Robusto</h3>
  <p>O tratamento adequado de erros em código assíncrono é crucial para criar aplicações robustas e com boa experiência do usuário.</p>
  <h4>Estratégias de Tratamento:</h4>
  <ul class="left_list">
    <li>Try/catch com async/await</li>
    <li>.catch() com Promises</li>
    <li>Tratamento específico por tipo de erro</li>
    <li>Retry automático</li>
    <li>Fallbacks e valores padrão</li>
  </ul>
</article>

<article class="item">
  <h4>Exemplos de Tratamento de Erros:</h4>
  <pre><code>// ✅ Tratamento básico com try/catch
async function operacaoComErro() {
  try {
    const dados = await fetch('/api/dados');
    
    if (!dados.ok) {
      throw new Error(`Erro HTTP: ${dados.status}`);
    }
    
    return await dados.json();
  } catch (erro) {
    console.error('Erro capturado:', erro.message);
    
    // Tratar diferentes tipos de erro
    if (erro.name === 'TypeError') {
      console.error('Erro de rede ou URL inválida');
    } else if (erro.name === 'SyntaxError') {
      console.error('Erro ao parsear JSON');
    } else {
      console.error('Erro desconhecido:', erro);
    }
    
    // Re-throw para permitir tratamento em nível superior
    throw erro;
  }
}

// ✅ Classe de erro customizada
class ApiError extends Error {
  constructor(message, status, response) {
    super(message);
    this.name = 'ApiError';
    this.status = status;
    this.response = response;
  }
}

// ✅ Função com tratamento específico
async function buscarUsuarioSeguro(id) {
  try {
    const response = await fetch(`/api/usuarios/${id}`);
    
    if (response.status === 404) {
      throw new ApiError('Usuário não encontrado', 404, response);
    }
    
    if (response.status === 403) {
      throw new ApiError('Acesso negado', 403, response);
    }
    
    if (!response.ok) {
      throw new ApiError(`Erro do servidor: ${response.status}`, response.status, response);
    }
    
    return await response.json();
  } catch (erro) {
    if (erro instanceof ApiError) {
      console.error(`Erro da API (${erro.status}):`, erro.message);
    } else {
      console.error('Erro de rede:', erro.message);
    }
    
    throw erro;
  }
}

// ✅ Retry com backoff exponencial
async function operacaoComRetry(operacao, maxTentativas = 3) {
  let ultimoErro;
  
  for (let tentativa = 1; tentativa <= maxTentativas; tentativa++) {
    try {
      return await operacao();
    } catch (erro) {
      ultimoErro = erro;
      
      // Não tentar novamente para erros 4xx (erro do cliente)
      if (erro.status >= 400 && erro.status < 500) {
        throw erro;
      }
      
      if (tentativa === maxTentativas) {
        break;
      }
      
      const delay = Math.pow(2, tentativa) * 1000; // 2s, 4s, 8s...
      console.log(`Tentativa ${tentativa} falhou, tentando novamente em ${delay}ms...`);
      
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  throw ultimoErro;
}

// ✅ Função com fallback
async function buscarDadosComFallback() {
  const urls = [
    'https://api.principal.com/dados',
    'https://api.backup.com/dados',
    '/dados/staticos.json'
  ];
  
  for (const url of urls) {
    try {
      const response = await fetch(url);
      const dados = await response.json();
      
      console.log(`Dados carregados de: ${url}`);
      return dados;
    } catch (erro) {
      console.warn(`Falha ao carregar de ${url}:`, erro.message);
      
      // Se for a última URL, usar dados padrão
      if (url === urls[urls.length - 1]) {
        console.log('Usando dados padrão');
        return { dados: [], origem: 'padrao' };
      }
    }
  }
}

// ✅ Tratamento global de erros
window.addEventListener('unhandledrejection', (event) => {
  console.error('Promise rejeitada não tratada:', event.reason);
  
  // Enviar erro para serviço de monitoramento
  enviarErroParaMonitoramento(event.reason);
  
  // Prevenir que o erro apareça no console
  event.preventDefault();
});

// ✅ Função para enviar erros para monitoramento
async function enviarErroParaMonitoramento(erro) {
  try {
    await fetch('/api/erros', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        mensagem: erro.message,
        stack: erro.stack,
        timestamp: new Date().toISOString(),
        url: window.location.href,
        userAgent: navigator.userAgent
      })
    });
  } catch (erroEnvio) {
    console.error('Falha ao enviar erro para monitoramento:', erroEnvio);
  }
}

// ✅ Wrapper para funções async com tratamento
function comTratamentoErro(fn) {
  return async (...args) => {
    try {
      return await fn(...args);
    } catch (erro) {
      console.error('Erro em função async:', erro);
      
      // Mostrar mensagem para o usuário
      mostrarNotificacaoErro('Ocorreu um erro. Tente novamente.');
      
      // Re-throw para permitir tratamento específico
      throw erro;
    }
  };
}

// ✅ Uso do wrapper
const buscarDadosSeguro = comTratamentoErro(async (id) => {
  const response = await fetch(`/api/dados/${id}`);
  return response.json();
});</code></pre>
</article>
</section>

<section class="container">
<article class="item">
  <h3>Prática: Aplicação com Carregamento de Dados</h3>
  <p>Vamos criar uma aplicação completa que demonstra carregamento assíncrono de dados, tratamento de erros e interface responsiva.</p>
  <h4>Objetivos da Prática:</h4>
  <ul class="left_list">
    <li>Carregar dados de API externa</li>
    <li>Implementar loading states</li>
    <li>Tratar erros graciosamente</li>
    <li>Implementar cache local</li>
    <li>Criar interface responsiva</li>
  </ul>
</article>

<article class="item">
  <h4>Aplicação Completa:</h4>
  <pre><code>// ✅ Classe para gerenciar estado da aplicação
class AppState {
  constructor() {
    this.loading = false;
    this.error = null;
    this.dados = [];
    this.listeners = [];
  }
  
  setLoading(loading) {
    this.loading = loading;
    this.notificar();
  }
  
  setError(error) {
    this.error = error;
    this.loading = false;
    this.notificar();
  }
  
  setDados(dados) {
    this.dados = dados;
    this.error = null;
    this.loading = false;
    this.notificar();
  }
  
  adicionarListener(listener) {
    this.listeners.push(listener);
  }
  
  notificar() {
    this.listeners.forEach(listener => listener(this));
  }
}

// ✅ Classe para gerenciar cache
class CacheManager {
  constructor() {
    this.cache = new Map();
    this.ttl = 5 * 60 * 1000; // 5 minutos
  }
  
  set(chave, dados) {
    this.cache.set(chave, {
      dados,
      timestamp: Date.now()
    });
  }
  
  get(chave) {
    const item = this.cache.get(chave);
    
    if (!item) return null;
    
    if (Date.now() - item.timestamp > this.ttl) {
      this.cache.delete(chave);
      return null;
    }
    
    return item.dados;
  }
  
  limpar() {
    this.cache.clear();
  }
}

// ✅ Classe para API
class ApiService {
  constructor() {
    this.baseUrl = 'https://jsonplaceholder.typicode.com';
    this.cache = new CacheManager();
  }
  
  async buscar(endpoint, opcoes = {}) {
    const url = `${this.baseUrl}${endpoint}`;
    const chaveCache = `${endpoint}-${JSON.stringify(opcoes)}`;
    
    // Verificar cache primeiro
    const dadosCache = this.cache.get(chaveCache);
    if (dadosCache) {
      console.log('Retornando dados do cache');
      return dadosCache;
    }
    
    try {
      const response = await fetch(url, {
        ...opcoes,
        headers: {
          'Content-Type': 'application/json',
          ...opcoes.headers
        }
      });
      
      if (!response.ok) {
        throw new Error(`Erro HTTP: ${response.status}`);
      }
      
      const dados = await response.json();
      
      // Armazenar no cache
      this.cache.set(chaveCache, dados);
      
      return dados;
    } catch (erro) {
      console.error('Erro na API:', erro);
      throw erro;
    }
  }
  
  async buscarUsuarios() {
    return this.buscar('/users');
  }
  
  async buscarUsuario(id) {
    return this.buscar(`/users/${id}`);
  }
  
  async buscarPosts(usuarioId) {
    return this.buscar(`/users/${usuarioId}/posts`);
  }
}

// ✅ Classe para UI
class UI {
  constructor() {
    this.container = document.querySelector('#app');
    this.api = new ApiService();
    this.state = new AppState();
    
    this.state.adicionarListener(this.render.bind(this));
    this.init();
  }
  
  init() {
    this.render();
    this.carregarUsuarios();
  }
  
  render(state = this.state) {
    this.container.innerHTML = `
      <div class="app">
        <header class="app-header">
          <h1>Usuários e Posts</h1>
          <button id="refresh-btn" class="btn btn-primary">
            Atualizar
          </button>
        </header>
        
        <main class="app-main">
          ${this.renderLoading(state)}
          ${this.renderError(state)}
          ${this.renderDados(state)}
        </main>
      </div>
    `;
    
    this.bindEvents();
  }
  
  renderLoading(state) {
    if (!state.loading) return '';
    
    return `
      <div class="loading">
        <div class="spinner"></div>
        <p>Carregando dados...</p>
      </div>
    `;
  }
  
  renderError(state) {
    if (!state.error) return '';
    
    return `
      <div class="error">
        <h3>Erro ao carregar dados</h3>
        <p>${state.error.message}</p>
        <button class="btn btn-secondary" onclick="app.retry()">
          Tentar Novamente
        </button>
      </div>
    `;
  }
  
  renderDados(state) {
    if (state.loading || state.error || !state.dados.length) return '';
    
    return `
      <div class="usuarios-grid">
        ${state.dados.map(usuario => this.renderUsuario(usuario)).join('')}
      </div>
    `;
  }
  
  renderUsuario(usuario) {
    return `
      <div class="usuario-card" data-user-id="${usuario.id}">
        <div class="usuario-header">
          <h3>${usuario.name}</h3>
          <p class="username">@${usuario.username}</p>
        </div>
        
        <div class="usuario-info">
          <p><strong>Email:</strong> ${usuario.email}</p>
          <p><strong>Website:</strong> 
            <a href="http://${usuario.website}" target="_blank">
              ${usuario.website}
            </a>
          </p>
          <p><strong>Empresa:</strong> ${usuario.company.name}</p>
        </div>
        
        <div class="usuario-actions">
          <button class="btn btn-small" data-action="ver-posts" data-user-id="${usuario.id}">
            Ver Posts
          </button>
        </div>
      </div>
    `;
  }
  
  bindEvents() {
    // Botão de atualizar
    const refreshBtn = document.querySelector('#refresh-btn');
    if (refreshBtn) {
      refreshBtn.addEventListener('click', () => this.carregarUsuarios());
    }
    
    // Botões de ver posts
    document.querySelectorAll('[data-action="ver-posts"]').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const userId = e.target.dataset.userId;
        this.carregarPosts(userId);
      });
    });
  }
  
  async carregarUsuarios() {
    this.state.setLoading(true);
    
    try {
      const usuarios = await this.api.buscarUsuarios();
      this.state.setDados(usuarios);
    } catch (erro) {
      this.state.setError(erro);
    }
  }
  
  async carregarPosts(usuarioId) {
    try {
      const [usuario, posts] = await Promise.all([
        this.api.buscarUsuario(usuarioId),
        this.api.buscarPosts(usuarioId)
      ]);
      
      this.mostrarModalPosts(usuario, posts);
    } catch (erro) {
      this.mostrarErro('Erro ao carregar posts do usuário');
    }
  }
  
  mostrarModalPosts(usuario, posts) {
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
      <div class="modal-content">
        <div class="modal-header">
          <h2>Posts de ${usuario.name}</h2>
          <button class="modal-close">&times;</button>
        </div>
        <div class="modal-body">
          <div class="posts-list">
            ${posts.map(post => `
              <div class="post-item">
                <h4>${post.title}</h4>
                <p>${post.body}</p>
              </div>
            `).join('')}
          </div>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Event listeners do modal
    modal.querySelector('.modal-close').addEventListener('click', () => {
      modal.remove();
    });
    
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.remove();
      }
    });
  }
  
  mostrarErro(mensagem) {
    // Implementar notificação de erro
    console.error(mensagem);
  }
  
  retry() {
    this.carregarUsuarios();
  }
}

// ✅ CSS para a aplicação
const css = `
  .app {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
  }
  
  .app-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 30px;
    padding-bottom: 20px;
    border-bottom: 2px solid #eee;
  }
  
  .usuarios-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
  }
  
  .usuario-card {
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 20px;
    background: white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    transition: transform 0.2s;
  }
  
  .usuario-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
  }
  
  .loading {
    text-align: center;
    padding: 40px;
  }
  
  .spinner {
    border: 4px solid #f3f3f3;
    border-top: 4px solid #3498db;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    animation: spin 1s linear infinite;
    margin: 0 auto 20px;
  }
  
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  .error {
    text-align: center;
    padding: 40px;
    color: #e74c3c;
  }
  
  .btn {
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
  }
  
  .btn-primary {
    background: #3498db;
    color: white;
  }
  
  .btn-secondary {
    background: #95a5a6;
    color: white;
  }
  
  .btn-small {
    padding: 5px 10px;
    font-size: 12px;
  }
`;

// ✅ Inicializar aplicação
document.addEventListener('DOMContentLoaded', () => {
  // Adicionar CSS
  const style = document.createElement('style');
  style.textContent = css;
  document.head.appendChild(style);
  
  // Inicializar app
  window.app = new UI();
});</code></pre>

  <picture>
    <source media="(min-width: 1024px)" srcset="/vitrine-ml5/mlab5/cursos/javascript/05/images/aplicacao_dados_desktop.png">
    <source media="(min-width: 600px)" srcset="/vitrine-ml5/mlab5/cursos/javascript/05/images/aplicacao_dados_tablet.png">
    <img src="/vitrine-ml5/mlab5/cursos/javascript/05/images/aplicacao_dados_mobile.png">
  </picture>
</article>
</section>

<span id="exercicio">
<p>Crie uma aplicação assíncrona completa com carregamento de dados:<p>
  <ul>
  <li>Título = Aplicação Assíncrona com Carregamento de Dados<br></li>
  <li>Implemente sistema de estado reativo<br></li>
  <li>Use Fetch API para requisições HTTP<br></li>
  <li>Implemente cache local com TTL<br></li>
  <li>Trate erros com retry automático<br></li>
  <li>Adicione loading states e feedback visual<br></li>
  <li>Crie interface responsiva e acessível<br></li>
</ul>
</p>Inclua funcionalidades como busca, filtros e paginação com operações assíncronas.</p>
</span>

  <form id="controles">
    <fieldset>
      <legend>Controles</legend>
    <h4>Escolha um template</h4>
    <select id="templateSelect">
      <option value="/vitrine-ml5/mlab5/templates/classico.html">Classico</option>
      <option value="/vitrine-ml5/mlab5/templates/moderno.html">Moderno</option>
      <option value="/vitrine-ml5/mlab5/templates/dark_mode.html">Dark Mode3</option>
    </select>

    <h4>Personalize</h4>
    <label>Cor de fundo: <input type="color" id="bgColor" value="#ffffff"></label><br>
    <label>Cor do texto: <input type="color" id="textColor" value="#000000"></label><br><br>

    <label>Fonte:
      <select id="fontFamily">
        <option value="Arial, sans-serif">Arial</option>
        <option value="Georgia, serif">Georgia</option>
        <option value="'Courier New', monospace">Courier New</option>
      </select><br>
    </label><br><br>
    </fieldset><br>
    <button onclick="salvarCustomizacao()">Salvar e Visualizar</button>
  </form>

<section class="container">
<article class="item">
    <a href="/vitrine-ml5/mlab5/playground" id="download-button" class="btn-large waves-effect waves-light teal lighten-1" >Playground</a>
</article>
</section>

</main>

<div id="footer-placeholder"></div>

<script>
  async function loadComponent(placeholderId, url) {
    try {
      const response = await fetch(url);
      if (!response.ok) throw new Error(`Erro ao carregar ${url}`);
      const html = await response.text();
      document.getElementById(placeholderId).innerHTML = html;
    } catch (error) {
      console.error(error);
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    loadComponent('header-placeholder', '/vitrine-ml5/mlab5/js/ui/components/header.html')
      .then(() => {
        const script = document.createElement('script');
        script.src = '/vitrine-ml5/mlab5/js/ui/components/navbar.js';
        document.body.appendChild(script);
      })
      .catch(error => {
        console.error("Erro ao carregar o header:", error);
      });

    loadComponent('footer-placeholder', '/vitrine-ml5/mlab5/js/ui/components/footer.html');
  });

  document.addEventListener('DOMContentLoaded', () => {
    const exercicio = document.getElementById('exercicio')?.innerText || "";
    const playgroundLink = document.querySelector('a[href="/vitrine-ml5/mlab5/playground"]'); 

    if (playgroundLink) {
      playgroundLink.addEventListener('click', (event) => {
        event.preventDefault();

        // Salva o texto das instruções
        localStorage.setItem('instrucoes', exercicio);

        // Salva o HTML do formulário inteiro
        const controles = document.getElementById('controles');
        localStorage.setItem('ajustes', controles.outerHTML);

        // Redireciona para o playground
        window.location.href = playgroundLink.href;
      });
    }
  });
</script>

</body>
</html>
