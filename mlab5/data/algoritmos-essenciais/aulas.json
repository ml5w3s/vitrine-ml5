[
  {
    "course": {
      "name": "Busca Linear e Busca Binária",
      "articles": [
        {
          "position": 0,
          "type": "banner",
          "image": {
            "desktop": "assets/images/banner_algoritmos_desktop.jpg",
            "tablet": "assets/images/banner_algoritmos_tablet.jpg",
            "mobile": "assets/images/banner_algoritmos_mobile.jpg"
          }
        },
        {
          "position": 1,
          "headline": "Introdução",
          "text": "A busca (ou pesquisa) é uma das operações mais fundamentais em programação: dado um conjunto de dados e um valor alvo, queremos descobrir se o valor existe e, se sim, em qual posição. Existem duas abordagens clássicas e complementares:",
          "list": [
            "Busca Linear (ou Sequencial): simples e direta.",
            "Busca Binária: extremamente eficiente, mas com pré-requisitos."
          ]
        },
        {
          "position": 2,
          "headline": "1. Busca Linear (Sequencial)",
          "text": "Como funciona: Percorre os elementos da coleção um por um, do início ao fim (ou até encontrar o alvo).",
          "list": [
            "Complexidade - Tempo: Melhor caso: O(1) → alvo está na primeira posição, Pior/Médio caso: O(n) → precisa percorrer toda a lista",
            "Complexidade - Espaço: O(1) → não precisa de memória extra"
          ]
        },
        {
          "code": [
            "def busca_linear(lista, alvo):",
            "    for i in range(len(lista)):",
            "        if lista[i] == alvo:",
            "            return i  # retorna o índice",
            "    return -1  # não encontrado"
          ],
          "position": 3
        },
        {
          "headline": "Vantagens e Desvantagens",
          "list": [
            "Vantagens: Simples de implementar, Funciona em dados não ordenados, Funciona em estruturas encadeadas",
            "Desvantagens: Lenta em listas grandes, Sempre O(n) no pior caso"
          ],
          "position": 4
        },
        {
          "headline": "Quando usar",
          "list": [
            "Lista pequena ou não ordenada",
            "Quando a ordenação prévia custaria mais que a busca linear repetida",
            "Estruturas como listas ligadas (onde acesso aleatório é caro)"
          ],
          "position": 5
        },
        {
          "position": 6,
          "headline": "2. Busca Binária",
          "text": "Só funciona em dados ordenados. A ideia é dividir o espaço de busca pela metade a cada passo:",
          "list": [
            "Olha o elemento do meio",
            "Se for o alvo → encontrado",
            "Se alvo for menor → descarta a metade direita",
            "Se alvo for maior → descarta a metade esquerda",
            "Repete até encontrar ou esgotar o intervalo"
          ]
        },
        {
          "code": [
            "def busca_binaria(lista, alvo):",
            "    esquerda = 0",
            "    direita = len(lista) - 1",
            "    ",
            "    while esquerda <= direita:",
            "        meio = (esquerda + direita) // 2",
            "        if lista[meio] == alvo:",
            "            return meio",
            "        elif lista[meio] < alvo:",
            "            esquerda = meio + 1",
            "        else:",
            "            direita = meio - 1",
            "    ",
            "    return -1  # não encontrado"
          ],
          "position": 7
        },
        {
          "headline": "Implementação Iterativa em Python",
          "position": 8
        },
        {
          "code": [
            "def busca_binaria_recursiva(lista, alvo, esquerda=0, direita=None):",
            "    if direita is None:",
            "        direita = len(lista) - 1",
            "    ",
            "    if esquerda > direita:",
            "        return -1",
            "    ",
            "    meio = (esquerda + direita) // 2",
            "    if lista[meio] == alvo:",
            "        return meio",
            "    elif lista[meio] < alvo:",
            "        return busca_binaria_recursiva(lista, alvo, meio + 1, direita)",
            "    else:",
            "        return busca_binaria_recursiva(lista, alvo, esquerda, meio - 1)"
          ],
          "position": 9
        },
        {
          "headline": "Vantagens e Desvantagens",
          "list": [
            "Vantagens: Extremamente rápida: O(log n), Muito eficiente para grandes volumes, Base de muitas estruturas avançadas (BSTs)",
            "Desvantagens: Exige dados previamente ordenados, Inserções frequentes podem exigir reordenação"
          ],
          "position": 10
        },
        {
          "headline": "Comparação Prática",
          "text": "Tamanho da lista (n) | Busca Linear (passos máx.) | Busca Binária (passos máx.)\n--- | --- | ---\n100 | 100 | ~7\n1.000 | 1.000 | ~10\n1.000.000 | 1.000.000 | ~20\n1.000.000.000 | 1.000.000.000 | ~30\n\n→ Com apenas ~30 comparações, a busca binária lida com bilhões de elementos!",
          "position": 11
        },
        {
          "headline": "Aplicações Reais",
          "list": [
            "Bibliotecas padrão: Python: módulo bisect (mantém lista ordenada e faz busca binária), Java: Arrays.binarySearch() e Collections.binarySearch(), JavaScript: pode ser implementada manualmente ou com bibliotecas, C++: std::binary_search, std::lower_bound",
            "Bancos de dados: índices ordenados usam variantes de busca binária (B-trees)",
            "Autocomplete: sugestões baseadas em prefixos ordenados",
            "APIs paginadas: encontrar posição aproximada em datasets ordenados",
            "Jogos: busca em tabelas de pontuação ordenadas",
            "Sistemas embarcados: quando memória é limitada, mas dados são estáticos e ordenados"
          ],
          "position": 12
        },
        {
          "headline": "Dicas para Entrevistas e Projetos",
          "list": [
            "Sempre pergunte/verifique se os dados estão ordenados antes de usar busca binária.",
            "Cuidado com overflow ao calcular o meio: em linguagens como Java/C++, use esquerda + (direita - esquerda) // 2.",
            "Saiba implementar ambas as versões (iterativa e recursiva).",
            "Entenda lower_bound / upper_bound: variações que retornam a posição de inserção."
          ],
          "text": "Dominar essas duas buscas é o primeiro passo sólido para entender eficiência algorítmica e resolver problemas reais de forma performática!",
          "position": 13
        },
        {
          "headline": "Exercícios Sugeridos",
          "list": [
            "Implemente ambas as buscas e teste com listas de tamanhos variados.",
            "Modifique a busca binária para contar quantas vezes o elemento aparece (lista com duplicatas).",
            "Use o módulo bisect do Python para manter uma lista ordenada enquanto insere elementos aleatórios."
          ],
          "text": "Dominar essas duas buscas é o primeiro passo sólido para entender eficiência algorítmica e resolver problemas reais de forma performática!",
          "position": 14
        }
      ]
    }
  }
]