[
  {
    "course": {
      "name": "üîç Busca Linear e Busca Bin√°ria",
      "articles": [
        {
          "position": 0,
          "type": "banner",
          "image": {
            "desktop": "assets/images/banner_algoritmos_desktop.png",
            "tablet": "assets/images/banner_algoritmos_tablet.png",
            "mobile": "assets/images/banner_algoritmos_mobile.png"
          }
        },
        {
          "position": 1,
          "headline": "Introdu√ß√£o",
          "text": "A busca (ou pesquisa) √© uma das opera√ß√µes mais fundamentais em programa√ß√£o: dado um conjunto de dados e um valor alvo, queremos descobrir se o valor existe e, se sim, em qual posi√ß√£o. Existem duas abordagens cl√°ssicas e complementares:",
          "list": [
            "Busca Linear (ou Sequencial): simples e direta.",
            "Busca Bin√°ria: extremamente eficiente, mas com pr√©-requisitos."
          ]
        },
        {
          "position": 2,
          "headline": "1. Busca Linear (Sequencial)",
          "text": "Como funciona: Percorre os elementos da cole√ß√£o um por um, do in√≠cio ao fim (ou at√© encontrar o alvo).",
          "list": [
            "Complexidade - Tempo: Melhor caso: O(1) ‚Üí alvo est√° na primeira posi√ß√£o, Pior/M√©dio caso: O(n) ‚Üí precisa percorrer toda a lista",
            "Complexidade - Espa√ßo: O(1) ‚Üí n√£o precisa de mem√≥ria extra"
          ]
        },
        {
          "code": [
            "def busca_linear(lista, alvo):",
            "    for i in range(len(lista)):",
            "        if lista[i] == alvo:",
            "            return i  # retorna o √≠ndice",
            "    return -1  # n√£o encontrado"
          ],
          "position": 3
        },
        {
          "position": 2,
          "text": "Usando o la√ßo de repeti√ß√£o, como o for por exemplo, √© poss√≠vel verificar cada posi√ß√£o da lista, em busca do alvo.",
          "video": "<iframe width='560' height='315' src='https://www.youtube.com/embed/dESIzDq4kIw?si=bGdAsmW8vq4iLfY2' title='YouTube video player' frameborder='0' allow='accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share' referrerpolicy='strict-origin-when-cross-origin' allowfullscreen></iframe>"
        },
        {
          "headline": "Vantagens e Desvantagens",
          "list": [
            "Vantagens: Simples de implementar, Funciona em dados n√£o ordenados, Funciona em estruturas encadeadas",
            "Desvantagens: Lenta em listas grandes, Sempre O(n) no pior caso"
          ],
          "position": 4
        },
        {
          "headline": "Quando usar",
          "list": [
            "Lista pequena ou n√£o ordenada",
            "Quando a ordena√ß√£o pr√©via custaria mais que a busca linear repetida",
            "Estruturas como listas ligadas (onde acesso aleat√≥rio √© caro)"
          ],
          "position": 5
        },
        {
          "position": 6,
          "headline": "2. Busca Bin√°ria",
          "text": "S√≥ funciona em dados ordenados. A ideia √© dividir o espa√ßo de busca pela metade a cada passo:",
          "list": [
            "Olha o elemento do meio",
            "Se for o alvo ‚Üí encontrado",
            "Se alvo for menor ‚Üí descarta a metade direita",
            "Se alvo for maior ‚Üí descarta a metade esquerda",
            "Repete at√© encontrar ou esgotar o intervalo"
          ]
        },
        {
          "code": [
            "def busca_binaria(lista, alvo):",
            "    esquerda = 0",
            "    direita = len(lista) - 1",
            "    ",
            "    while esquerda <= direita:",
            "        meio = (esquerda + direita) // 2",
            "        if lista[meio] == alvo:",
            "            return meio",
            "        elif lista[meio] < alvo:",
            "            esquerda = meio + 1",
            "        else:",
            "            direita = meio - 1",
            "    ",
            "    return -1  # n√£o encontrado"
          ],
          "position": 7
        },
        {
          "position": 7.5,
          "text": "Se a lista tem 100 itens, verifica se o alvo √© iqual a 50, se n√£o, verifica se o alvo √© menor que 50, se sim, elimina a metade maior maior iqual a 50, e verifica se o alvo √© igual a 25, se n√£o verifica se ...",
          "image": {
            "desktop": "assets/images/cursos/algoritmos/fluxo_busca_binaria.png",
            "tablet": "assets/images/cursos/algoritmos/fluxo_busca_binaria.png",
            "mobile": "assets/images/cursos/algoritmos/fluxo_busca_binaria.png",
            "caption": "Eliminando as metades onde n√£o est√°"
          }
        },
        {
          "headline": "Implementa√ß√£o Iterativa em Python",
          "text": "Voc√™ pode importar biblioteca para gerar uma lista com n√∫meros aleat√≥rios e tamb√©m uma biblioteca para medir o tempo da busca para efeito de compara√ß√£o.",
          "code": [
            "import random",
            "import time",
            "    ",
            "tamanho_lista = 1_000_000",
            "numeros = sorted(random.sample(range(1, 10_000_001), tamanho_lista))"
          ],
          "position": 8
        },
        {
          "code": [
            "def busca_binaria_recursiva(lista, alvo, esquerda=0, direita=None):",
            "    if direita is None:",
            "        direita = len(lista) - 1",
            "    ",
            "    if esquerda > direita:",
            "        return -1",
            "    ",
            "    meio = (esquerda + direita) // 2",
            "    if lista[meio] == alvo:",
            "        return meio",
            "    elif lista[meio] < alvo:",
            "        return busca_binaria_recursiva(lista, alvo, meio + 1, direita)",
            "    else:",
            "        return busca_binaria_recursiva(lista, alvo, esquerda, meio - 1)"
          ],
          "position": 9
        },
        {
          "headline": "Vantagens e Desvantagens",
          "list": [
            "Vantagens: Extremamente r√°pida: O(log n), Muito eficiente para grandes volumes, Base de muitas estruturas avan√ßadas (BSTs)",
            "Desvantagens: Exige dados previamente ordenados, Inser√ß√µes frequentes podem exigir reordena√ß√£o"
          ],
          "position": 10
        },
        {
          "headline": "Compara√ß√£o Pr√°tica",
          "text": "Tamanho da lista (n) | Busca Linear (passos m√°x.) | Busca Bin√°ria (passos m√°x.)\n--- | --- | ---\n100 | 100 | ~7\n1.000 | 1.000 | ~10\n1.000.000 | 1.000.000 | ~20\n1.000.000.000 | 1.000.000.000 | ~30\n\n‚Üí Com apenas ~30 compara√ß√µes, a busca bin√°ria lida com bilh√µes de elementos!",
          "position": 11
        },
        {
          "headline": "Aplica√ß√µes Reais",
          "list": [
            "Bibliotecas padr√£o: Python: m√≥dulo bisect (mant√©m lista ordenada e faz busca bin√°ria), Java: Arrays.binarySearch() e Collections.binarySearch(), JavaScript: pode ser implementada manualmente ou com bibliotecas, C++: std::binary_search, std::lower_bound",
            "Bancos de dados: √≠ndices ordenados usam variantes de busca bin√°ria (B-trees)",
            "Autocomplete: sugest√µes baseadas em prefixos ordenados",
            "APIs paginadas: encontrar posi√ß√£o aproximada em datasets ordenados",
            "Jogos: busca em tabelas de pontua√ß√£o ordenadas",
            "Sistemas embarcados: quando mem√≥ria √© limitada, mas dados s√£o est√°ticos e ordenados"
          ],
          "position": 12
        },
        {
          "headline": "Dicas para Entrevistas e Projetos",
          "list": [
            "Sempre pergunte/verifique se os dados est√£o ordenados antes de usar busca bin√°ria.",
            "Cuidado com overflow ao calcular o meio: em linguagens como Java/C++, use esquerda + (direita - esquerda) // 2.",
            "Saiba implementar ambas as vers√µes (iterativa e recursiva).",
            "Entenda lower_bound / upper_bound: varia√ß√µes que retornam a posi√ß√£o de inser√ß√£o."
          ],
          "text": "Dominar essas duas buscas √© o primeiro passo s√≥lido para entender efici√™ncia algor√≠tmica e resolver problemas reais de forma perform√°tica!",
          "position": 13
        },
        {
          "headline": "Exerc√≠cios Sugeridos",
          "list": [
            "Implemente ambas as buscas e teste com listas de tamanhos variados.",
            "Modifique a busca bin√°ria para contar quantas vezes o elemento aparece (lista com duplicatas).",
            "Use o m√≥dulo bisect do Python para manter uma lista ordenada enquanto insere elementos aleat√≥rios."
          ],
          "text": "Dominar essas duas buscas √© o primeiro passo s√≥lido para entender efici√™ncia algor√≠tmica e resolver problemas reais de forma perform√°tica!",
          "position": 14
        }
      ],
      "playground": {
        "url": "#/course/algoritmos-essenciais/lesson/01/playground"
      }
    }
  },
  {
    "course": {
      "name": "üî¢ Algoritmos de Ordena√ß√£o",
      "articles": [
        {
          "position": 0,
          "type": "banner",
          "image": {
            "desktop": "assets/images/banner_algoritmos_desktop.png",
            "tablet": "assets/images/banner_algoritmos_tablet.png",
            "mobile": "assets/images/banner_algoritmos_mobile.png"
          }
        },
        {
          "position": 1,
          "headline": "Introdu√ß√£o",
          "text": "A ordena√ß√£o de dados √© fundamental para otimizar buscas e processamento. Existem diversos algoritmos, divididos geralmente em quadr√°ticos (mais simples e lentos) e log-lineares (mais complexos e eficientes)."
        },
        {
          "position": 2,
          "headline": "1. Algoritmos Quadr√°ticos (O(n¬≤))",
          "text": "S√£o algoritmos simples, √∫teis para pequenas listas ou fins did√°ticos, mas ineficientes para grandes volumes de dados.",
          "list": [
            "Bubble Sort: Flutua os maiores elementos para o fim.",
            "Insertion Sort: Constr√≥i a lista ordenada um item por vez (como cartas de baralho).",
            "Selection Sort: Seleciona o menor elemento e o coloca na posi√ß√£o correta."
          ]
        },
        {
          "position": 3,
          "headline": "Exemplo: Bubble Sort em Python",
          "code": [
            "def bubble_sort(lista):",
            "    n = len(lista)",
            "    for i in range(n):",
            "        for j in range(0, n-i-1):",
            "            if lista[j] > lista[j+1]:",
            "                lista[j], lista[j+1] = lista[j+1], lista[j]",
            "    return lista"
          ],
          "programmingLanguage": "python"
        },
        {
          "position": 4,
          "headline": "2. Algoritmos Eficientes (O(n log n))",
          "text": "Utilizam a estrat√©gia 'Dividir para Conquistar' para lidar com grandes volumes de dados.",
          "list": [
            "Quick Sort: Escolhe um piv√¥ e particiona a lista.",
            "Merge Sort: Divide a lista ao meio recursivamente e intercala as partes ordenadas.",
            "Heap Sort: Utiliza uma estrutura de heap bin√°rio."
          ]
        },
        {
          "position": 5,
          "headline": "Exemplo: Quick Sort (Simplificado)",
          "code": [
            "def quick_sort(lista):",
            "    if len(lista) <= 1:",
            "        return lista",
            "    pivo = lista[len(lista) // 2]",
            "    esquerda = [x for x in lista if x < pivo]",
            "    meio = [x for x in lista if x == pivo]",
            "    direita = [x for x in lista if x > pivo]",
            "    return quick_sort(esquerda) + meio + quick_sort(direita)"
          ],
          "programmingLanguage": "python"
        },
        {
          "position": 6,
          "headline": "3. Compara√ß√£o de Performance",
          "text": "Em testes pr√°ticos com listas aleat√≥rias, algoritmos O(n log n) superam drasticamente os quadr√°ticos conforme n cresce.",
          "list": [
            "1.000 itens: Quase impercept√≠vel.",
            "10.000 itens: Quadr√°ticos come√ßam a engasgar (~1s vs ~0.01s).",
            "100.000 itens: Quadr√°ticos podem levar minutos; Eficientes levam fra√ß√µes de segundo."
          ]
        },
        {
          "position": 7,
          "headline": "4. Fun√ß√µes Nativas",
          "text": "Na pr√°tica, raramente implementamos esses algoritmos do zero. Usamos as fun√ß√µes otimizadas da linguagem (Timsort no Python/Java).",
          "list": [
            "Python: lista.sort() (in-place) ou sorted(lista) (nova lista).",
            "JavaScript: array.sort().",
            "Java: Arrays.sort() ou Collections.sort()."
          ]
        },
        {
          "position": 8,
          "headline": "Customiza√ß√£o (Python)",
          "text": "Podemos ordenar objetos complexos usando o par√¢metro 'key'.",
          "code": [
            "alunos = [{'nome': 'Ana', 'nota': 8}, {'nome': 'Beto', 'nota': 5}]",
            "# Ordenar por nota",
            "alunos.sort(key=lambda x: x['nota'])"
          ],
          "programmingLanguage": "python"
        }
      ],
      "playground": {
        "url": "#/course/algoritmos-essenciais/lesson/02/playground"
      }
    }
  },
  {
    "course": {
      "name": "üìè Estruturas de Dados Lineares Avan√ßadas",
      "articles": [
        {
          "position": 0,
          "type": "banner",
          "image": {
            "desktop": "assets/images/banner_algoritmos_desktop.png",
            "tablet": "assets/images/banner_algoritmos_tablet.png",
            "mobile": "assets/images/banner_algoritmos_mobile.png"
          }
        },
        {
          "position": 1,
          "headline": "Introdu√ß√£o",
          "text": "Al√©m dos arrays b√°sicos, existem estruturas especializadas que otimizam certas opera√ß√µes de inser√ß√£o e remo√ß√£o, fundamentais para resolver problemas espec√≠ficos de forma eficiente."
        },
        {
          "position": 2,
          "headline": "1. Pilhas (Stacks)",
          "text": "Seguem o princ√≠pio LIFO (Last In, First Out) - o √∫ltimo a entrar √© o primeiro a sair. Pense em uma pilha de pratos.",
          "list": [
            "Opera√ß√µes principais: Push (inserir no topo) e Pop (remover do topo).",
            "Complexidade: O(1) para inser√ß√£o e remo√ß√£o no topo.",
            "Aplica√ß√µes: Controle de chamadas de fun√ß√£o (call stack), desfazer (undo) em editores, verifica√ß√£o de par√™nteses."
          ]
        },
        {
          "position": 3,
          "headline": "Exemplo: Pilha em Python",
          "text": "Em Python, usamos listas comuns como pilhas, pois o m√©todo .append() e .pop() (sem argumento) s√£o otimizados para o final da lista.",
          "code": [
            "pilha = []",
            "pilha.append('A')  # Push",
            "pilha.append('B')  # Push",
            "",
            "topo = pilha.pop() # Pop -> Retorna 'B'",
            "print(pilha)       # ['A']"
          ],
          "programmingLanguage": "python"
        },
        {
          "position": 4,
          "headline": "2. Filas (Queues)",
          "text": "Seguem o princ√≠pio FIFO (First In, First Out) - o primeiro a entrar √© o primeiro a sair. Pense em uma fila de banco.",
          "list": [
            "Opera√ß√µes principais: Enqueue (inserir no final) e Dequeue (remover do in√≠cio).",
            "Aplica√ß√µes: Gerenciamento de impressoras, processamento de tarefas em background, BFS (Busca em Largura)."
          ]
        },
        {
          "position": 5,
          "headline": "Exemplo: Fila Eficiente em Python",
          "text": "Usar listas como fila (pop(0)) √© ineficiente O(n). A forma correta √© usar 'collections.deque'.",
          "code": [
            "from collections import deque",
            "",
            "fila = deque(['Cliente 1', 'Cliente 2'])",
            "fila.append('Cliente 3')      # Enqueue",
            "",
            "atendido = fila.popleft()     # Dequeue eficiente O(1)",
            "print(atendido)               # 'Cliente 1'"
          ],
          "programmingLanguage": "python"
        },
        {
          "position": 6,
          "headline": "3. Deques (Double-Ended Queues)",
          "text": "Uma generaliza√ß√£o de pilhas e filas. Permite inser√ß√£o e remo√ß√£o eficientes O(1) em ambas as extremidades.",
          "list": [
            "Estrutura flex√≠vel: Pode atuar como pilha ou fila dependendo da necessidade.",
            "Aplica√ß√µes: Algoritmo de janelas deslizantes (Sliding Window), hist√≥rico de navega√ß√£o, filas de prioridade com extremidades fixas."
          ]
        },
        {
          "position": 7,
          "headline": "4. Listas Encadeadas (Linked Lists)",
          "text": "Diferente dos arrays, onde os dados s√£o cont√≠guos na mem√≥ria, listas encadeadas s√£o compostas por 'n√≥s' que apontam para o pr√≥ximo elemento.",
          "list": [
            "Vantagem: Tamanho din√¢mico real (n√£o precisa realocar mem√≥ria como arrays din√¢micos) e inser√ß√µes/remo√ß√µes no meio s√£o mais simples se voc√™ j√° tem a refer√™ncia do n√≥.",
            "Desvantagem: N√£o permite acesso aleat√≥rio (√≠ndice direto). Para pegar o 10¬∫ elemento, precisa percorrer os 9 anteriores. Acesso √© O(n).",
            "Uso pr√°tico: Base para implementa√ß√£o de Grafos e tabelas Hash com encadeamento."
          ]
        }
      ],
      "playground": {
        "url": "#/course/algoritmos-essenciais/lesson/03/playground"
      }
    }
  },
  {
    "course": {
      "name": "üå≥ √Årvores Bin√°rias e Traversais",
      "articles": [
        {
          "position": 0,
          "type": "banner",
          "image": {
            "desktop": "assets/images/banner_algoritmos_desktop.png",
            "tablet": "assets/images/banner_algoritmos_tablet.png",
            "mobile": "assets/images/banner_algoritmos_mobile.png"
          }
        },
        {
          "position": 1,
          "headline": "Introdu√ß√£o √†s √Årvores",
          "text": "Diferente de arrays e listas (lineares), √°rvores s√£o estruturas hier√°rquicas. S√£o compostas por n√≥s, onde um n√≥ 'pai' pode ter refer√™ncias para n√≥s 'filhos'."
        },
        {
          "position": 2,
          "headline": "1. √Årvore Bin√°ria de Busca (BST)",
          "text": "Uma √Årvore Bin√°ria √© aquela onde cada n√≥ tem no m√°ximo dois filhos (esquerda e direita). Uma BST (Binary Search Tree) segue uma regra estrita que permite buscas r√°pidas:",
          "list": [
            "Todos os n√≥s √† ESQUERDA s√£o MENORES que o n√≥ atual.",
            "Todos os n√≥s √† DIREITA s√£o MAIORES que o n√≥ atual.",
            "Isso permite busca, inser√ß√£o e remo√ß√£o com complexidade m√©dia de O(log n)."
          ]
        },
        {
          "position": 3,
          "headline": "Implementa√ß√£o de N√≥ (Python)",
          "code": [
            "class Node:",
            "    def __init__(self, valor):",
            "        self.valor = valor",
            "        self.esquerda = None",
            "        self.direita = None"
          ],
          "programmingLanguage": "python"
        },
        {
          "position": 4,
          "headline": "2. Traversals (Percursos)",
          "text": "Traversal √© o processo de visitar todos os n√≥s da √°rvore. A ordem muda tudo.",
          "list": [
            "In-order (E-R-D): Esquerda, Raiz, Direita. (Em BST, imprime ordenado!).",
            "Pre-order (R-E-D): Raiz, Esquerda, Direita. (√ötil para copiar √°rvores).",
            "Post-order (E-D-R): Esquerda, Direita, Raiz. (√ötil para deletar √°rvores ou calcular express√µes matem√°ticas)."
          ]
        },
        {
          "position": 5,
          "headline": "Exemplo: In-Order Recursivo",
          "code": [
            "def in_order(no):",
            "    if no:",
            "        in_order(no.esquerda)",
            "        print(no.valor)",
            "        in_order(no.direita)"
          ],
          "programmingLanguage": "python"
        },
        {
          "position": 6,
          "headline": "3. Breadth-First Search (BFS)",
          "text": "Conhecido como percurso 'por n√≠veis'. Visita a raiz, depois todos do n√≠vel 1, depois todos do n√≠vel 2, etc.",
          "list": [
            "N√£o usa recurs√£o simples, usa uma Fila (Queue) auxiliar.",
            "√ötil para encontrar o caminho mais curto em √°rvores n√£o ponderadas ou para serializar a √°rvore n√≠vel por n√≠vel."
          ]
        },
        {
          "position": 7,
          "headline": "Exemplo: BFS com Fila",
          "code": [
            "from collections import deque",
            "",
            "def bfs(raiz):",
            "    if not raiz: return",
            "    fila = deque([raiz])",
            "    while fila:",
            "        no = fila.popleft()",
            "        print(no.valor)",
            "        if no.esquerda: fila.append(no.esquerda)",
            "        if no.direita: fila.append(no.direita)"
          ],
          "programmingLanguage": "python"
        },
        {
          "position": 8,
          "headline": "4. Aplica√ß√µes Pr√°ticas",
          "text": "√Årvores est√£o em toda parte na computa√ß√£o, n√£o apenas em bancos de dados.",
          "list": [
            "DOM (Document Object Model): O HTML √© uma √°rvore de elementos.",
            "JSON: Objetos aninhados formam uma estrutura de √°rvore.",
            "Sistemas de Arquivos: Pastas dentro de pastas.",
            "Compiladores: √Årvores de Sintaxe Abstrata (AST) para entender c√≥digo."
          ]
        }
      ],
      "playground": {
        "url": "#/course/algoritmos-essenciais/lesson/04/playground"
      }
    }
  },
  {
    "course": {
      "name": "üï∏Ô∏è Grafos ‚Äì Representa√ß√£o e Buscas B√°sicas",
      "articles": [
        {
          "position": 0,
          "type": "banner",
          "image": {
            "desktop": "assets/images/banner_algoritmos_desktop.png",
            "tablet": "assets/images/banner_algoritmos_tablet.png",
            "mobile": "assets/images/banner_algoritmos_mobile.png"
          }
        },
        {
          "position": 1,
          "headline": "O que s√£o Grafos?",
          "text": "Um grafo √© uma estrutura n√£o-linear composta por v√©rtices (n√≥s) e arestas (conex√µes entre os n√≥s). √â a estrutura mais vers√°til para modelar relacionamentos complexos."
        },
        {
          "position": 2,
          "headline": "1. Representa√ß√£o de Grafos",
          "text": "Como armazenamos um grafo na mem√≥ria? Duas formas principais:",
          "list": [
            "Lista de Adjac√™ncia: Um dicion√°rio onde cada chave √© um n√≥ e o valor √© uma lista de vizinhos. Eficiente em espa√ßo para grafos esparsos (poucas conex√µes).",
            "Matriz de Adjac√™ncia: Uma grade 2D (tabela). R√°pida para verificar se existe conex√£o direta entre dois n√≥s espec√≠ficos (O(1)), mas gasta muita mem√≥ria (O(V¬≤))."
          ]
        },
        {
          "position": 3,
          "headline": "Exemplo: Lista de Adjac√™ncia (Python)",
          "code": [
            "grafo = {",
            "    'A': ['B', 'C'],",
            "    'B': ['A', 'D', 'E'],",
            "    'C': ['A', 'F'],",
            "    'D': ['B'],",
            "    'E': ['B', 'F'],",
            "    'F': ['C', 'E']",
            "}"
          ],
          "programmingLanguage": "python"
        },
        {
          "position": 4,
          "headline": "2. Busca em Profundidade (DFS)",
          "text": "Explora o grafo indo o mais fundo poss√≠vel em cada ramifica√ß√£o antes de retroceder (backtracking). Utiliza uma Pilha (Stack) ou a pr√≥pria pilha de chamada da recurs√£o.",
          "list": [
            "Estrat√©gia: Visite o n√≥, marque como visitado, chame a DFS para cada vizinho n√£o visitado.",
            "Aplica√ß√µes: Detectar ciclos, encontrar componentes conectados, resolver labirintos, ordena√ß√£o topol√≥gica."
          ]
        },
        {
          "position": 5,
          "headline": "Implementa√ß√£o DFS (Recursiva)",
          "code": [
            "def dfs_recursiva(grafo, vertice, visitados=None):",
            "    if visitados is None:",
            "        visitados = set()",
            "    ",
            "    visitados.add(vertice)",
            "    print(vertice)",
            "    ",
            "    for vizinho in grafo[vertice]:",
            "        if vizinho not in visitados:",
            "            dfs_recursiva(grafo, vizinho, visitados)",
            "    return visitados"
          ],
          "programmingLanguage": "python"
        },
        {
          "position": 6,
          "headline": "3. Busca em Largura (BFS)",
          "text": "Explora os n√≥s vizinhos antes de ir para os vizinhos dos vizinhos (camadas). Utiliza uma Fila (Queue).",
          "list": [
            "Estrat√©gia: Adicione o n√≥ na fila, enquanto a fila n√£o estiver vazia, remova o primeiro, visite seus vizinhos n√£o marcados e adicione-os na fila.",
            "Propriedade Importante: Garante encontrar o caminho mais curto (menor n√∫mero de arestas) em grafos n√£o ponderados."
          ]
        },
        {
          "position": 7,
          "headline": "Implementa√ß√£o BFS",
          "code": [
            "from collections import deque",
            "",
            "def bfs(grafo, inicio):",
            "    visitados = set([inicio])",
            "    fila = deque([inicio])",
            "",
            "    while fila:",
            "        vertice = fila.popleft()",
            "        print(vertice)",
            "",
            "        for vizinho in grafo[vertice]:",
            "            if vizinho not in visitados:",
            "                visitados.add(vizinho)",
            "                fila.append(vizinho)"
          ],
          "programmingLanguage": "python"
        },
        {
          "position": 8,
          "headline": "4. Aplica√ß√µes Reais",
          "list": [
            "Redes Sociais: Sugest√£o de 'Pessoas que voc√™ talvez conhe√ßa' (BFS para encontrar amigos de amigos).",
            "GPS e Mapas: Encontrar rotas entre dois pontos (BFS ou Dijkstra).",
            "Gerenciadores de Pacotes (npm, pip): Resolver ordem de instala√ß√£o de depend√™ncias para evitar conflitos (DFS/Topological Sort).",
            "Web Crawlers: O Google usa grafos para navegar e indexar links da internet."
          ]
        }
      ],
      "playground": {
        "url": "#/course/algoritmos-essenciais/lesson/05/playground"
      }
    }
  },
  {
    "course": {
      "name": "üìç Algoritmos em Grafos ‚Äì Caminhos Mais Curtos",
      "articles": [
        {
          "position": 0,
          "type": "banner",
          "image": {
            "desktop": "assets/images/banner_algoritmos_desktop.png",
            "tablet": "assets/images/banner_algoritmos_tablet.png",
            "mobile": "assets/images/banner_algoritmos_mobile.png"
          }
        },
        {
          "position": 1,
          "headline": "Introdu√ß√£o",
          "text": "Encontrar o caminho mais curto entre dois pontos √© um dos problemas mais cl√°ssicos da computa√ß√£o. A solu√ß√£o ideal depende se as arestas do grafo t√™m pesos (custos/dist√¢ncias) ou n√£o."
        },
        {
          "position": 2,
          "headline": "1. Grafos N√£o Ponderados: BFS",
          "text": "Quando todas as arestas t√™m o mesmo 'custo' (ou nenhum peso), a Busca em Largura (BFS) √© a solu√ß√£o √≥tima.",
          "list": [
            "Por que funciona? A BFS explora camada por camada. A primeira vez que ela alcan√ßa o n√≥ destino, garante que foi pelo menor n√∫mero de saltos poss√≠vel.",
            "Complexidade: O(V + E) - Linear em rela√ß√£o ao tamanho do grafo."
          ]
        },
        {
          "position": 3,
          "headline": "2. Grafos Ponderados: Algoritmo de Dijkstra",
          "text": "Em mapas reais, estradas t√™m comprimentos diferentes. Ir de A para B em 1 salto de 100km √© pior que 2 saltos de 10km. A BFS falha aqui. Precisamos do Dijkstra.",
          "list": [
            "Conceito: Mant√©m uma estimativa da menor dist√¢ncia conhecida para cada n√≥. Sempre escolhe expandir o n√≥ n√£o visitado com a MENOR dist√¢ncia acumulada atual (abordagem gulosa/greedy).",
            "Estrutura chave: Uma Fila de Prioridade (Priority Queue) para pegar eficientemente o n√≥ mais 'barato' a cada passo."
          ]
        },
        {
          "position": 4,
          "headline": "Exemplo: Dijkstra com heapq (Python)",
          "code": [
            "import heapq",
            "",
            "def dijkstra(grafo, inicio):",
            "    # Dist√¢ncias iniciais infinitas",
            "    distancias = {no: float('inf') for no in grafo}",
            "    distancias[inicio] = 0",
            "    ",
            "    # Fila de prioridade: (dist√¢ncia, n√≥)",
            "    pq = [(0, inicio)]",
            "    ",
            "    while pq:",
            "        dist_atual, u = heapq.heappop(pq)",
            "        ",
            "        # Se achamos um caminho pior, ignoramos",
            "        if dist_atual > distancias[u]:",
            "            continue",
            "        ",
            "        for vizinho, peso in grafo[u].items():",
            "            dist = dist_atual + peso",
            "            ",
            "            # Relaxamento: se achamos caminho melhor",
            "            if dist < distancias[vizinho]:",
            "                distancias[vizinho] = dist",
            "                heapq.heappush(pq, (dist, vizinho))",
            "                ",
            "    return distancias"
          ],
          "programmingLanguage": "python"
        },
        {
          "position": 5,
          "headline": "3. Limita√ß√µes do Dijkstra",
          "text": "O algoritmo de Dijkstra N√ÉO funciona corretamente se houver arestas com pesos negativos (pode entrar em loops infinitos ou dar respostas erradas).",
          "list": [
            "Solu√ß√£o para pesos negativos: Algoritmo de Bellman-Ford (mais lento, mas robusto)."
          ]
        },
        {
          "position": 6,
          "headline": "4. Aplica√ß√µes Pr√°ticas",
          "list": [
            "Sistemas de Navega√ß√£o (GPS): Waze, Google Maps (usa varia√ß√µes como A* que √© um Dijkstra direcionado por heur√≠stica).",
            "Redes de Computadores: Protocolos de roteamento (OSPF) para decidir o caminho dos pacotes de dados.",
            "Jogos: Movimenta√ß√£o de personagens (Pathfinding) em mapas com terrenos de custos variados (√°gua, montanha, estrada)."
          ]
        }
      ],
      "playground": {
        "url": "#/course/algoritmos-essenciais/lesson/06/playground"
      }
    }
  },
  {
    "course": {
      "name": "üîë Hash Tables e Hashing",
      "articles": [
        {
          "position": 0,
          "type": "banner",
          "image": {
            "desktop": "assets/images/banner_algoritmos_desktop.png",
            "tablet": "assets/images/banner_algoritmos_tablet.png",
            "mobile": "assets/images/banner_algoritmos_mobile.png"
          }
        },
        {
          "position": 1,
          "headline": "Introdu√ß√£o √†s Hash Tables",
          "text": "As Tabelas Hash (ou Dicion√°rios/Mapas) s√£o fundamentais para o desenvolvimento moderno. Elas permitem associar chaves a valores, permitindo uma recupera√ß√£o de dados extremamente r√°pida, quase instant√¢nea."
        },
        {
          "position": 2,
          "headline": "1. Fun√ß√µes de Hash e Colis√µes",
          "text": "Uma fun√ß√£o de hash transforma uma chave (como uma string) em um √≠ndice num√©rico. O principal desafio √© a 'Colis√£o', que ocorre quando duas chaves diferentes resultam no mesmo √≠ndice.",
          "list": [
            "Fun√ß√£o de Hash: Deve ser r√°pida e distribuir as chaves de forma uniforme.",
            "Tratamento por Encadeamento: O √≠ndice aponta para uma lista de elementos que colidiram.",
            "Endere√ßamento Aberto: Procura o pr√≥ximo espa√ßo vazio dispon√≠vel na tabela."
          ]
        },
        {
          "position": 3,
          "headline": "2. Opera√ß√µes O(1)",
          "text": "Diferente de listas (O(n)) ou √°rvores (O(log n)), as Tabelas Hash oferecem, em m√©dia, tempo constante para as opera√ß√µes principais:",
          "list": [
            "Inser√ß√£o: O(1) m√©dio.",
            "Busca: O(1) m√©dio.",
            "Remo√ß√£o: O(1) m√©dio."
          ]
        },
        {
          "position": 4,
          "headline": "Exemplo Pr√°tico em Python",
          "text": "Em Python, a implementa√ß√£o padr√£o de Hash Table √© o dicion√°rio (`dict`).",
          "code": [
            "tabela = {}",
            "tabela['usuario_123'] = {'nome': 'Alice', 'nivel': 5}",
            "",
            "# Busca instant√¢nea pela chave",
            "print(tabela['usuario_123']['nome'])  # Sa√≠da: Alice",
            "",
            "# Remo√ß√£o",
            "del tabela['usuario_123']"
          ],
          "programmingLanguage": "python"
        },
        {
          "position": 5,
          "headline": "3. Dicion√°rios e Mapas em outras linguagens",
          "text": "Embora o conceito seja o mesmo, a sintaxe e algumas propriedades variam entre as linguagens:",
          "list": [
            "JavaScript: Objetos `{}` e a classe `Map`.",
            "Java: `HashMap` e `Hashtable`.",
            "C++: `std::unordered_map`."
          ]
        },
        {
          "position": 6,
          "headline": "4. Aplica√ß√£o: Contagem de Frequ√™ncias",
          "text": "Um dos usos mais comuns √© contar a ocorr√™ncia de itens em uma cole√ß√£o.",
          "code": [
            "def contar_frequencia(lista):",
            "    contador = {}",
            "    for item in lista:",
            "        contador[item] = contador.get(item, 0) + 1",
            "    return contador",
            "",
            "dados = ['uva', 'ma√ß√£', 'uva', 'laranja', 'ma√ß√£', 'uva']",
            "print(contar_frequencia(dados)) ",
            "# Sa√≠da: {'uva': 3, 'ma√ß√£': 2, 'laranja': 1}"
          ],
          "programmingLanguage": "python"
        },
        {
          "position": 7,
          "headline": "5. Outras Aplica√ß√µes Reais",
          "list": [
            "Sistemas de Cache: Armazenar resultados de consultas lentas indexados por seus par√¢metros (Memoization).",
            "Autentica√ß√£o: Tabelas Hash s√£o usadas para verificar rapidamente se um token de sess√£o √© v√°lido.",
            "Bancos de Dados NoSQL: Muitos utilizam o modelo chave-valor baseado em hashing para alta performance."
          ]
        }
      ],
      "playground": {
        "url": "#/course/algoritmos-essenciais/lesson/07/playground"
      }
    }
  },
  {
    "course": {
      "name": "üèîÔ∏è Heaps e Priority Queues",
      "articles": [
        {
          "position": 0,
          "type": "banner",
          "image": {
            "desktop": "assets/images/banner_algoritmos_desktop.png",
            "tablet": "assets/images/banner_algoritmos_tablet.png",
            "mobile": "assets/images/banner_algoritmos_mobile.png"
          }
        },
        {
          "position": 1,
          "headline": "O que √© um Heap?",
          "text": "Um Heap √© uma √°rvore bin√°ria especializada que satisfaz a 'Propriedade do Heap'. √â a estrutura ideal quando precisamos acesso r√°pido ao 'maior' ou 'menor' elemento."
        },
        {
          "position": 2,
          "headline": "1. Tipos de Heap",
          "list": [
            "Min-Heap: O pai √© sempre MENOR ou igual aos filhos. A raiz √© o M√çNIMO global.",
            "Max-Heap: O pai √© sempre MAIOR ou igual aos filhos. A raiz √© o M√ÅXIMO global."
          ]
        },
        {
          "position": 3,
          "headline": "2. Opera√ß√µes Principais",
          "text": "Heaps s√£o geralmente implementados sobre arrays simples.",
          "list": [
            "Inser√ß√£o (Push): O(log n) - Adiciona no final e sobe (bubble-up).",
            "Remo√ß√£o da Raiz (Pop): O(log n) - Remove o topo, move o √∫ltimo para o topo e desce (bubble-down).",
            "Espiar (Peek): O(1) - Acesso imediato √† prioridade m√°xima."
          ]
        },
        {
          "position": 4,
          "headline": "3. Heap Sort",
          "text": "Um algoritmo de ordena√ß√£o eficiente O(n log n) que usa a estrutura de heap.",
          "code": [
            "import heapq",
            "",
            "def heapsort(iterable):",
            "    h = []",
            "    for value in iterable:",
            "        heapq.heappush(h, value)",
            "    ",
            "    return [heapq.heappop(h) for i in range(len(h))]",
            "",
            "print(heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]))"
          ],
          "programmingLanguage": "python"
        },
        {
          "position": 5,
          "headline": "4. Priority Queues (Filas de Prioridade)",
          "text": "Diferente de uma fila comum (FIFO), aqui sai primeiro quem tem maior prioridade (ou menor valor, dependendo da implementa√ß√£o).",
          "list": [
            "Aplica√ß√µes: Agendamento de processos (CPU), pathfinding (Dijkstra/A*), compress√£o de dados (Huffman)."
          ]
        },
        {
          "position": 6,
          "headline": "5. Problema do Top-K (Leaderboards)",
          "text": "Como manter o 'Top 10' jogadores em tempo real com milh√µes de usu√°rios? Usar um Min-Heap de tamanho K √© muito mais eficiente que ordenar tudo.",
          "code": [
            "import heapq",
            "",
            "pontuacoes = [10, 500, 20, 5, 100, 30]",
            "",
            "# Encontra os 3 maiores eficientemente O(n log k)",
            "top3 = heapq.nlargest(3, pontuacoes)",
            "print(top3)  # [500, 100, 30]"
          ],
          "programmingLanguage": "python"
        }
      ],
      "playground": {
        "url": "#/course/algoritmos-essenciais/lesson/08/playground"
      }
    }
  },
  {
    "course": {
      "name": "üöÄ T√©cnicas Avan√ßadas Essenciais",
      "articles": [
        {
          "position": 0,
          "type": "banner",
          "image": {
            "desktop": "assets/images/banner_algoritmos_desktop.png",
            "tablet": "assets/images/banner_algoritmos_tablet.png",
            "mobile": "assets/images/banner_algoritmos_mobile.png"
          }
        },
        {
          "position": 1,
          "headline": "Introdu√ß√£o",
          "text": "Nesta aula final, exploramos t√©cnicas que resolvem problemas de alta complexidade. Enquanto algoritmos b√°sicos focam em 'como fazer', t√©cnicas avan√ßadas focam em 'como fazer de forma eficiente' ou 'como explorar todas as possibilidades sem travar o sistema'."
        },
        {
          "position": 2,
          "headline": "1. Programa√ß√£o Din√¢mica (DP)",
          "text": "A Programa√ß√£o Din√¢mica √© usada quando um problema pode ser dividido em subproblemas sobrepostos. Em vez de calcular a mesma coisa v√°rias vezes, salvamos o resultado (Memoization) para uso futuro.",
          "list": [
            "Memoization: T√©cnica Top-Down (recursiva com cache).",
            "Tabulation: T√©cnica Bottom-Up (iterativa preenchendo uma tabela).",
            "Exemplos: Fibonacci, Problema da Mochila (Knapsack), Maior Subsequ√™ncia Comum (LCS)."
          ]
        },
        {
          "position": 3,
          "headline": "Exemplo: Fibonacci O(n) com Memoization",
          "code": [
            "def fib_dinamico(n, memo={}):",
            "    if n in memo: return memo[n]",
            "    if n <= 2: return 1",
            "    memo[n] = fib_dinamico(n-1, memo) + fib_dinamico(n-2, memo)",
            "    return memo[n]"
          ],
          "programmingLanguage": "python"
        },
        {
          "position": 4,
          "headline": "2. Backtracking",
          "text": "Backtracking √© um refinamento da busca bruta. Ele tenta construir uma solu√ß√£o passo a passo e, se perceber que o caminho atual n√£o levar√° a uma solu√ß√£o v√°lida, ele volta (backtrack) para o ponto anterior e tenta outra op√ß√£o.",
          "list": [
            "Pruning (Poda): Ignorar ramos da √°rvore de decis√£o que sabemos ser in√∫teis.",
            "Aplica√ß√µes: Sudoku, Problema das N-Rainhas, Gerar todas as Permuta√ß√µes de uma lista."
          ]
        },
        {
          "position": 5,
          "headline": "Exemplo: Gerando Permuta√ß√µes",
          "code": [
            "def permutar(lista, inicio=0):",
            "    if inicio == len(lista):",
            "        print(lista)",
            "    for i in range(inicio, len(lista)):",
            "        lista[inicio], lista[i] = lista[i], lista[inicio]",
            "        permutar(lista, inicio + 1)",
            "        lista[inicio], lista[i] = lista[i], lista[inicio] # backtrack"
          ],
          "programmingLanguage": "python"
        },
        {
          "position": 6,
          "headline": "3. Algoritmos em Strings",
          "text": "Busca de padr√µes em textos √© vital. A busca simples (Brute Force) compara cada posi√ß√£o, o que pode ser ineficiente em textos gigantes.",
          "list": [
            "KMP (Knuth-Morris-Pratt): Evita voltar no texto principal pr√©-processando o padr√£o.",
            "Rabin-Karp: Usa hashing para encontrar padr√µes de forma probabil√≠stica.",
            "Aplica√ß√µes: Editores de texto (Ctrl+F), Bioinform√°tica, Compiladores."
          ]
        },
        {
          "position": 7,
          "headline": "4. Projeto Final Integrador",
          "text": "Para consolidar o curso, o aluno deve aplicar m√∫ltiplas t√©cnicas em um sistema real.",
          "list": [
            "Mini-GPS: Usa Grafos (Dijkstra) para rotas e Tabelas Hash para indexar nomes de ruas.",
            "Sistema de Recomenda√ß√£o: Usa Algoritmos de Ordena√ß√£o e Filtragem Baseada em Prefer√™ncias (Hash Tables).",
            "Solucionador de Quebra-Cabe√ßas: Usa Backtracking para resolver desafios l√≥gicos."
          ]
        }
      ],
      "playground": {
        "url": "#/course/algoritmos-essenciais/lesson/09/playground"
      }
    }
  }
]